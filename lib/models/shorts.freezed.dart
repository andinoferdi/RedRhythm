// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'shorts.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

Shorts _$ShortsFromJson(Map<String, dynamic> json) {
  return _Shorts.fromJson(json);
}

/// @nodoc
mixin _$Shorts {
  String get id => throw _privateConstructorUsedError;
  String get genresId => throw _privateConstructorUsedError;
  String get videoUrl => throw _privateConstructorUsedError;
  String get artistId => throw _privateConstructorUsedError;
  String get songId => throw _privateConstructorUsedError;
  String? get title => throw _privateConstructorUsedError;
  String? get hashtags => throw _privateConstructorUsedError;
  String? get artistName => throw _privateConstructorUsedError;
  String? get songTitle => throw _privateConstructorUsedError;
  String? get thumbnailUrl => throw _privateConstructorUsedError;
  int get views => throw _privateConstructorUsedError;
  int get likes => throw _privateConstructorUsedError;
  DateTime? get createdAt => throw _privateConstructorUsedError;
  DateTime? get updatedAt => throw _privateConstructorUsedError;

  /// Serializes this Shorts to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of Shorts
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $ShortsCopyWith<Shorts> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ShortsCopyWith<$Res> {
  factory $ShortsCopyWith(Shorts value, $Res Function(Shorts) then) =
      _$ShortsCopyWithImpl<$Res, Shorts>;
  @useResult
  $Res call(
      {String id,
      String genresId,
      String videoUrl,
      String artistId,
      String songId,
      String? title,
      String? hashtags,
      String? artistName,
      String? songTitle,
      String? thumbnailUrl,
      int views,
      int likes,
      DateTime? createdAt,
      DateTime? updatedAt});
}

/// @nodoc
class _$ShortsCopyWithImpl<$Res, $Val extends Shorts>
    implements $ShortsCopyWith<$Res> {
  _$ShortsCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of Shorts
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? genresId = null,
    Object? videoUrl = null,
    Object? artistId = null,
    Object? songId = null,
    Object? title = freezed,
    Object? hashtags = freezed,
    Object? artistName = freezed,
    Object? songTitle = freezed,
    Object? thumbnailUrl = freezed,
    Object? views = null,
    Object? likes = null,
    Object? createdAt = freezed,
    Object? updatedAt = freezed,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      genresId: null == genresId
          ? _value.genresId
          : genresId // ignore: cast_nullable_to_non_nullable
              as String,
      videoUrl: null == videoUrl
          ? _value.videoUrl
          : videoUrl // ignore: cast_nullable_to_non_nullable
              as String,
      artistId: null == artistId
          ? _value.artistId
          : artistId // ignore: cast_nullable_to_non_nullable
              as String,
      songId: null == songId
          ? _value.songId
          : songId // ignore: cast_nullable_to_non_nullable
              as String,
      title: freezed == title
          ? _value.title
          : title // ignore: cast_nullable_to_non_nullable
              as String?,
      hashtags: freezed == hashtags
          ? _value.hashtags
          : hashtags // ignore: cast_nullable_to_non_nullable
              as String?,
      artistName: freezed == artistName
          ? _value.artistName
          : artistName // ignore: cast_nullable_to_non_nullable
              as String?,
      songTitle: freezed == songTitle
          ? _value.songTitle
          : songTitle // ignore: cast_nullable_to_non_nullable
              as String?,
      thumbnailUrl: freezed == thumbnailUrl
          ? _value.thumbnailUrl
          : thumbnailUrl // ignore: cast_nullable_to_non_nullable
              as String?,
      views: null == views
          ? _value.views
          : views // ignore: cast_nullable_to_non_nullable
              as int,
      likes: null == likes
          ? _value.likes
          : likes // ignore: cast_nullable_to_non_nullable
              as int,
      createdAt: freezed == createdAt
          ? _value.createdAt
          : createdAt // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      updatedAt: freezed == updatedAt
          ? _value.updatedAt
          : updatedAt // ignore: cast_nullable_to_non_nullable
              as DateTime?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$ShortsImplCopyWith<$Res> implements $ShortsCopyWith<$Res> {
  factory _$$ShortsImplCopyWith(
          _$ShortsImpl value, $Res Function(_$ShortsImpl) then) =
      __$$ShortsImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String id,
      String genresId,
      String videoUrl,
      String artistId,
      String songId,
      String? title,
      String? hashtags,
      String? artistName,
      String? songTitle,
      String? thumbnailUrl,
      int views,
      int likes,
      DateTime? createdAt,
      DateTime? updatedAt});
}

/// @nodoc
class __$$ShortsImplCopyWithImpl<$Res>
    extends _$ShortsCopyWithImpl<$Res, _$ShortsImpl>
    implements _$$ShortsImplCopyWith<$Res> {
  __$$ShortsImplCopyWithImpl(
      _$ShortsImpl _value, $Res Function(_$ShortsImpl) _then)
      : super(_value, _then);

  /// Create a copy of Shorts
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? genresId = null,
    Object? videoUrl = null,
    Object? artistId = null,
    Object? songId = null,
    Object? title = freezed,
    Object? hashtags = freezed,
    Object? artistName = freezed,
    Object? songTitle = freezed,
    Object? thumbnailUrl = freezed,
    Object? views = null,
    Object? likes = null,
    Object? createdAt = freezed,
    Object? updatedAt = freezed,
  }) {
    return _then(_$ShortsImpl(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      genresId: null == genresId
          ? _value.genresId
          : genresId // ignore: cast_nullable_to_non_nullable
              as String,
      videoUrl: null == videoUrl
          ? _value.videoUrl
          : videoUrl // ignore: cast_nullable_to_non_nullable
              as String,
      artistId: null == artistId
          ? _value.artistId
          : artistId // ignore: cast_nullable_to_non_nullable
              as String,
      songId: null == songId
          ? _value.songId
          : songId // ignore: cast_nullable_to_non_nullable
              as String,
      title: freezed == title
          ? _value.title
          : title // ignore: cast_nullable_to_non_nullable
              as String?,
      hashtags: freezed == hashtags
          ? _value.hashtags
          : hashtags // ignore: cast_nullable_to_non_nullable
              as String?,
      artistName: freezed == artistName
          ? _value.artistName
          : artistName // ignore: cast_nullable_to_non_nullable
              as String?,
      songTitle: freezed == songTitle
          ? _value.songTitle
          : songTitle // ignore: cast_nullable_to_non_nullable
              as String?,
      thumbnailUrl: freezed == thumbnailUrl
          ? _value.thumbnailUrl
          : thumbnailUrl // ignore: cast_nullable_to_non_nullable
              as String?,
      views: null == views
          ? _value.views
          : views // ignore: cast_nullable_to_non_nullable
              as int,
      likes: null == likes
          ? _value.likes
          : likes // ignore: cast_nullable_to_non_nullable
              as int,
      createdAt: freezed == createdAt
          ? _value.createdAt
          : createdAt // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      updatedAt: freezed == updatedAt
          ? _value.updatedAt
          : updatedAt // ignore: cast_nullable_to_non_nullable
              as DateTime?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ShortsImpl implements _Shorts {
  const _$ShortsImpl(
      {required this.id,
      required this.genresId,
      required this.videoUrl,
      required this.artistId,
      required this.songId,
      this.title,
      this.hashtags,
      this.artistName,
      this.songTitle,
      this.thumbnailUrl,
      this.views = 0,
      this.likes = 0,
      this.createdAt,
      this.updatedAt});

  factory _$ShortsImpl.fromJson(Map<String, dynamic> json) =>
      _$$ShortsImplFromJson(json);

  @override
  final String id;
  @override
  final String genresId;
  @override
  final String videoUrl;
  @override
  final String artistId;
  @override
  final String songId;
  @override
  final String? title;
  @override
  final String? hashtags;
  @override
  final String? artistName;
  @override
  final String? songTitle;
  @override
  final String? thumbnailUrl;
  @override
  @JsonKey()
  final int views;
  @override
  @JsonKey()
  final int likes;
  @override
  final DateTime? createdAt;
  @override
  final DateTime? updatedAt;

  @override
  String toString() {
    return 'Shorts(id: $id, genresId: $genresId, videoUrl: $videoUrl, artistId: $artistId, songId: $songId, title: $title, hashtags: $hashtags, artistName: $artistName, songTitle: $songTitle, thumbnailUrl: $thumbnailUrl, views: $views, likes: $likes, createdAt: $createdAt, updatedAt: $updatedAt)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ShortsImpl &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.genresId, genresId) ||
                other.genresId == genresId) &&
            (identical(other.videoUrl, videoUrl) ||
                other.videoUrl == videoUrl) &&
            (identical(other.artistId, artistId) ||
                other.artistId == artistId) &&
            (identical(other.songId, songId) || other.songId == songId) &&
            (identical(other.title, title) || other.title == title) &&
            (identical(other.hashtags, hashtags) ||
                other.hashtags == hashtags) &&
            (identical(other.artistName, artistName) ||
                other.artistName == artistName) &&
            (identical(other.songTitle, songTitle) ||
                other.songTitle == songTitle) &&
            (identical(other.thumbnailUrl, thumbnailUrl) ||
                other.thumbnailUrl == thumbnailUrl) &&
            (identical(other.views, views) || other.views == views) &&
            (identical(other.likes, likes) || other.likes == likes) &&
            (identical(other.createdAt, createdAt) ||
                other.createdAt == createdAt) &&
            (identical(other.updatedAt, updatedAt) ||
                other.updatedAt == updatedAt));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      genresId,
      videoUrl,
      artistId,
      songId,
      title,
      hashtags,
      artistName,
      songTitle,
      thumbnailUrl,
      views,
      likes,
      createdAt,
      updatedAt);

  /// Create a copy of Shorts
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$ShortsImplCopyWith<_$ShortsImpl> get copyWith =>
      __$$ShortsImplCopyWithImpl<_$ShortsImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ShortsImplToJson(
      this,
    );
  }
}

abstract class _Shorts implements Shorts {
  const factory _Shorts(
      {required final String id,
      required final String genresId,
      required final String videoUrl,
      required final String artistId,
      required final String songId,
      final String? title,
      final String? hashtags,
      final String? artistName,
      final String? songTitle,
      final String? thumbnailUrl,
      final int views,
      final int likes,
      final DateTime? createdAt,
      final DateTime? updatedAt}) = _$ShortsImpl;

  factory _Shorts.fromJson(Map<String, dynamic> json) = _$ShortsImpl.fromJson;

  @override
  String get id;
  @override
  String get genresId;
  @override
  String get videoUrl;
  @override
  String get artistId;
  @override
  String get songId;
  @override
  String? get title;
  @override
  String? get hashtags;
  @override
  String? get artistName;
  @override
  String? get songTitle;
  @override
  String? get thumbnailUrl;
  @override
  int get views;
  @override
  int get likes;
  @override
  DateTime? get createdAt;
  @override
  DateTime? get updatedAt;

  /// Create a copy of Shorts
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$ShortsImplCopyWith<_$ShortsImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
